Design and implement a data structure for Least Frequently Used (LFU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least frequently used item before inserting a new item. For the purpose of this problem, when there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LFUCache cache = new LFUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.get(3);       // returns 3.
cache.put(4, 4);    // evicts key 1.
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4




public class LFUCache
    {

        Dictionary<int, int> dataDict = null;
        Dictionary<int, int> dataCount = null;
        Dictionary<int, HashSet<int>> dataLink = null;
        Dictionary<int, long> dataRecent = null;
        int _capacity = Int32.MinValue;

        public LFUCache(int capacity)
        {
            _capacity = capacity;
            dataDict = new Dictionary<int, int>();
            dataCount = new Dictionary<int, int>();
            dataLink = new Dictionary<int, HashSet<int>>();
            dataRecent = new Dictionary<int, long>();
        }

        public int Get(int key)
        {

            if (!dataDict.ContainsKey(key))
            {
                return -1;
            }

            var count = dataCount[key];
            dataCount[key] = count + 1;
            dataRecent[key] = DateTime.UtcNow.Ticks;
            if (dataLink.ContainsKey(count))
            {
                dataLink[count].Remove(key);
                if (dataLink[count].Count == 0)
                    dataLink.Remove(count);
            }

            if (!dataLink.ContainsKey(count + 1))
                dataLink.Add(count + 1, new HashSet<int>());
            dataLink[count + 1].Add(key);

            return dataDict[key];
        }

        public void Put(int key, int value)
        {

            if (_capacity == 0)
            {
                return;
            }

            if (dataDict.ContainsKey(key))
            {
                dataDict[key] = value;
                Get(key);
                return;
            }

            if (dataDict.Count == _capacity)
            {
                var c = dataLink.Keys.Min();
                var k = dataLink[c];
                int keyToRemove = Int32.MinValue;
                long recentUsed = long.MaxValue;
                foreach (var item in k)
                {
                    if (dataRecent[item] < recentUsed)
                    {
                        keyToRemove = item;
                        recentUsed = dataRecent[item];
                    }
                }
                dataDict.Remove(keyToRemove);
                dataCount.Remove(keyToRemove);
                dataLink[c].Remove(keyToRemove);
                dataRecent.Remove(keyToRemove);
                if (dataLink[c].Count == 0)
                    dataLink.Remove(c);
            }
            dataDict.Add(key, value);
            dataCount.Add(key, 1);
            dataRecent.Add(key, DateTime.UtcNow.Ticks);
            if (!dataLink.ContainsKey(1))
                dataLink.Add(1, new HashSet<int>());

            dataLink[1].Add(key);
        }
    }
